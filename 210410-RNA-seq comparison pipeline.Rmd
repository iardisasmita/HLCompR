
RNA-seq Comparison Pipeline
_____________________________________________________________

--- PART 1: Uploading User Sample Data ---

Here, users will add their own sample data. The data that they should upload are the *read count table* and *coldata table* (both in .csv format)

```{r}
user_Data <- read.csv("user_count_data.csv", header = TRUE) #read count table
user_colData <- read.csv("user_colData.csv", header = TRUE, row.names=1) #coldata table
```

--- PART 2: Combining User Sample Data with Our "Training" Data ---

We will then combine the user sample data with our training data (combining both the *read count* and *coldata*). The function to merge them will be up to Gautam. Important things are that the order of the ensmbl gene names in the *user count table* should match *our count table* AND the order of column/sample name in *merged count table* should also match the order of "id" column in *merged colData* (see train_count_data.csv and train_coldata.csv).

```{r}
train_Data <- read.csv("train_count_data.csv", header = TRUE) #read count table
train_colData <- read.csv("train_colData.csv", header = TRUE, row.names=1) #coldata table

#SOME FUNCTIONS TO MERGE user_Data with train_Data and user_ColData with train_colData
#Up to you Gautam!

merged_Data <- function(x) #please change this function accordingly
merged_colData <- function(y) #please change this function accordingly
```

--- PART 3: Tidying The Merged Count Data ---

Now we need to "tidy" up the merged count data. This process includes: *1* removing the string after "." in the ensmbl gene names, *2* removing duplicates of ensmbl genes if any, *3* removing genes with total row counts <10. I provide my code for the tidy up process but I am sure you have better ones!

```{r}
# (1) Removing the string after "." in the ensmbl gene names
removedot <- gsub("\\..*","", merged_Data[,1]) #the gene name should be in the first column, otherwise adjust the value of "[,1]"
merged_Data[,1] <- removedot

# (2) Removing duplicate of ensmbl genes
merged_Data <- merged_Data[!duplicated(merged_Data$ensmbl_gene_name),] #"ensmbl_gene_name" should be the header for where the ensmbl gene column, otherwise adjust it accordingly

# (3) Removing genes with total row counts <10
merged_Data <- merged_Data[rowSums(merged_Data[,-1])>9,]

```

--- PART 4: Applying DESeq2 VST Function/Transformation ---

After we have a nicely merged count data, no we can do the first data transformation needed in the pipeline, which is VST!

```{r}
#load the DESeq2 package
library(DESeq2)

#create dds object, the important part is the qn_vstdata and colData variables. The design will not affect any results but it has to be there because DESeq2 requires it.
dds <- DESeqDataSetFromMatrix(countData=merged_Data, 
                              colData=merged_colData, 
                              design=~Type, #can be any random column name from the colData, does not matter
                              tidy = TRUE)

#applying the VST transformation
vst_data <- vst(dds,blind=FALSE)

#change the vst data format from a "Large DESeqTransform" into a matrix
vst_data <- as.matrix(assay(vst_data)) #this step can be combined with the previous step also if you like
```

--- PART 5: Applying Quantile Normalization ---

After we have the VST transformed data, the next step is to do quantile normalization.

```{r}
#load the required package
library(preprocessCore)

#run the quantile normalization function
qn_vstdata <- normalize.quantiles(vst_data)

#after quantile normalization, the colnames and rownames are gone, so we need to retrieve them back
rownames(qn_vstdata) <- rownames(vst_data)
colnames(qn_vstdata) <- colnames(vst_data)
```

--- PART 6: Making PCA Plot ---

Yay, now we have all the data we need, time to make a PCA plot!

```{r}
#load the ggplot
library(ggplot2)

#specify the number of genes to take into account in the pca plot
ntop = 5000

#specify the labeling, we just take all the colname from merged_Coldata 
intgroup = colnames(merged_colData)

#calculate row variance and ordered them decending to select the highest variance genes (ntop)
rv <- rowVars(as.matrix(qn_vstdata[,]))
select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,length(rv)))]

#create the PCA
pca_res <- prcomp(t(qn_vstdata[select,]), scale. = FALSE)
percentVar <- pca_res$sdev^2/sum(pca_res$sdev^2)

#prepare the label for the PCA plot
intgroup.df <- as.data.frame(merged_colData[,intgroup, drop = FALSE])

#combine the PCA with the label
d <- data.frame(PC1 = pca_res$x[, 1], PC2 = pca_res$x[, 2], 
                intgroup.df, name = colnames(qn_vstdata[,]))

#plot the PCA
ggplot(data = d, aes_string(x = "PC1", y = "PC2", color = "Type")) + 
  geom_point(size = 3) + 
  xlab(paste0("PC1: ", round(percentVar[1] * 100), "% variance")) + 
  ylab(paste0("PC2: ", round(percentVar[2] * 100), "% variance")) + 
  coord_fixed()
```

--- PART 7: Converting Ensemble Gene into HGNC ---

To create heatmap and boxplot of distance based similarity, first we have to change the gene name into a more recognizable format (in this case we will use the HGNC symbol).

```{r}
library(biomaRt)
library(dplyr)

## Build a biomart query 
# In the example below, I use the human gene annotation from Ensembl release 82 located on "sep2015.archive.ensembl.org", More about the ensembl_build can be found on "http://www.ensembl.org/info/website/archives/index.html"
dataset="hsapiens_gene_ensembl"
mart = biomaRt::useMart("ENSEMBL_MART_ENSEMBL", dataset = dataset, 
                        host = paste0("jan2020", ".archive.ensembl.org"), path = "/biomart/martservice", archive = FALSE)
#listAttributes(mart)
annotations <- biomaRt::getBM(mart = mart, attributes=c("ensembl_gene_id", "external_gene_name"), 
                              useCache = FALSE) #useCahche=FALSE -> need to update version of R / bioconductor
annotations <- dplyr::transmute(annotations, ensembl_gene_id, external_gene_name)

# Filter and re-order gene.annotations to match the order in your input genes list
gene_name <- annotations %>% dplyr::filter(ensembl_gene_id %in% rownames(qn_vstdata))
gene_name <- gene_name[order(match(gene_name$ensembl_gene_id, rownames(qn_vstdata))),]

# Merging annotation with dataset
qn_vstdata2 <- merge(as.data.frame(gene_name), as.data.frame(qn_vstdata), by.x = "ensembl_gene_id", by.y = 0, all = TRUE)

# Tidy up the final dataframe
qn_vstdata2 <- qn_vstdata2[!duplicated(qn_vstdata2$external_gene_name),] #remove duplicate of gene name
rownames(qn_vstdata2) <- qn_vstdata2[,2] #make the HGNC as rownames
qn_vstdata2 <- qn_vstdata2[,c(-1,-2)] #remove unnecessary column
```

--- PART 8: Making Heatmap ---

The heatmap can be generated based on a selected gene set. In this example, we will use a gene set from .csv file. Ideally we want the user to be able to input the geneset easily (just like enrichr and panther).

```{r}
library(pheatmap)
library(RColorBrewer)

#define the sample information displayed for the heatmap legend
coldata <- merged_colData[,c(0,1,2)]

#set the upper and lower border of the heatmap intensity (CAN WE MAKE THIS ADJUSTABLE BY SLIDER?)
breaksList = seq(-6, 6, by = 0.01)

#upload the gene to be selected
selectgene <- as.vector(read.csv("example_geneset.csv", header=TRUE)[,])

#subset the dataset using the selected gene set
matrix <- qn_vstdata2[selectgene,]

#remove NA containing rows (CAN WE GIVE WARNING FOR GENES THAT ARE NOT AVAILABLE?)
matrix <- matrix[complete.cases(matrix),]

#apply mean centering for easier data interpretation
matrix <- matrix - rowMeans(matrix)

#create the heatmap (CAN WE MAKE THE CLUSTER OPTION TWEAKABLE BY USER?)
pheatmap(matrix, color = colorRampPalette(c("dodgerblue3","white","firebrick1"))(length(breaksList)),
         fontsize = 7, fontsize_row = 6, fontsize_col = 6,
         cellheight = 7, cellwidth = NA,
         breaks = breaksList , annotation_col= coldata,
         cluster_rows = TRUE, cluster_cols = TRUE,
         cutree_rows = 1, cutree_cols = 3,
         border_color = NA)
```

--- PART 9: Creating Boxplot of Distance Based Similarity (DBS) ---

The last plot we want to create is the distance-based similarity boxplot. This plot describes the similarity of each sample to all PHH/liver controls in the dataset. *The gene set used for DBS is the same as used for heatmap*.

```{r}
library(reshape)
library(tidyr)
library(forcats)

#calculate euclidean distance between sample in a certain gene set
euclid <- as.matrix(dist(t(matrix), method = "euclidean"))

#subset only the distance to PHH and liver controls
comdist <- euclid[grep("PHH|Liver",rownames(euclid)),]

#transform the euclidean distance into distance-based similarity
comsim <- (max(comdist)-comdist)/max(comdist)

#remove the rownames, it will mess up downstream table transformation
rownames(comsim) <- NULL

#we change the table format from "wide" into "long"
box_dist <- melt(comsim, varnames = c("Number","Names"))
box_dist <- box_dist[,-1] #we don't need the first column

#adding author and cell type information
com_box_dist <- merge(box_dist, merged_colData, by.x = "Names", by.y = 0, all = TRUE)

#combining author and cell type so replicates will be plotted in the same box
com_box_dist <- com_box_dist %>%
  unite(com, Author, Type, Type2, sep = "_", na.rm = T, remove = F)

ggplot(com_box_dist, aes(x = fct_reorder(com, value), y = value, fill = Type)) + 
  geom_boxplot() + 
  ylim(0,1) +
  xlab("") +
  ylab(expression("Distance-based similarity (to PHH/Liver)")) + 
  theme(axis.text.x = element_text(angle = 270,vjust = 0.5, hjust = 0))

```

